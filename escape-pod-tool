#!/usr/bin/perl
use strict;
use warnings;

my $url = 'https://en.wikipedia.org/wiki/List_of_Escape_Pod_episodes';
my $csvDelim = ';';

sub getMP3Url($);
sub fetchMP3Url($);
sub browserLoadArticle($);

sub csv($);
sub cell($);
sub padl($$);
sub maxLen(@);
sub parseTableRow($$);

my $cmds = join "|", qw(
  --csv --url --mp3url --mp3filename
);
my $usage = "Usage:
  $0 [$cmds [EPNUM EPNUM ..]]
    Fetch episode list from $url.
    Parse it, and print certain info.

    --csv {default if no args specified}
      Print episode info in CSV with delim=$csvDelim
    --url
      Print the article url for each EPNUM, using the links in the above url.
    --mp3url
      Fetch the download URL from the escape pod article url
    --mp3filename
      Same as --mp3url, but only print the filename

    EPNUM are escape pod episode numbers; if none are specified, all are used.
";

sub main(@){
  my $cmd = shift;
  $cmd = '--csv' if not defined $cmd;
  die $usage if $cmd !~ /^($cmds)$/;

  my @nums = @_;
  die $usage if (grep {$_ !~ /^\d+$/} @nums) > 0;

  my %okNums = map {$_+0 => 1} @nums;


  my $html = `wget -O - $url 2>/dev/null`;
  my @epNums;
  my @tableRows;
  while($html =~ /<tr>\s*<td>(\d+)<\/td>.*?<\/tr>/gs){
    push @tableRows, $&;
    push @epNums, $1;
  }

  my $maxLen = maxLen @epNums;

  my $eps = {};
  for my $tableRow(@tableRows){
    my $ep = parseTableRow $tableRow, $maxLen;
    next if keys %okNums > 0 and not defined $okNums{$$ep{number}+0};
    $$eps{$$ep{number}} = $ep;
  }

  if($cmd eq '--csv'){
    print csv $eps;
  }elsif($cmd eq '--url'){
    for my $epNum(sort keys %$eps){
      print "$$eps{$epNum}{url}\n";
    }
  }elsif($cmd eq '--mp3url' or $cmd eq '--mp3filename'){
    for my $epNum(sort keys %$eps){
      my $mp3Url = getMP3Url($$eps{$epNum}{articleUrl});
      if($cmd eq '--mp3filename' and $mp3Url =~ /([^\/]*\.mp3)$/){
        print "$1\n";
      }else{
        print "$mp3Url\n";
      }
    }
  }
}

sub getMP3Url($){
  my $articleUrl = shift;
  my $mp3Url = undef;

  my $attempts;

  $attempts = 10;
  while(not defined $mp3Url and $attempts > 0){
    $attempts--;
    $mp3Url = fetchMP3Url $articleUrl;
  }
  if(not defined $mp3Url){
    browserLoadArticle $articleUrl
  }
  $attempts = 10;
  while(not defined $mp3Url and $attempts > 0){
    $attempts--;
    $mp3Url = fetchMP3Url $articleUrl;
  }
  return $mp3Url;
}
sub fetchMP3Url($){
  my $articleUrl = shift;
  my $html = `curl -L "$articleUrl" 2>/dev/null`;
  if($html =~ /href="([^"]*\.mp3)"/){
    return $1;
  }
  $html = `wget "$articleUrl" -O - 2>/dev/null`;
  if($html =~ /href="([^"]*\.mp3)"/){
    return $1;
  }
  return undef;
}
sub browserLoadArticle($){
  my $articleUrl = shift;
  system "uzbl $articleUrl >/dev/null 2>/dev/null &";
  sleep 5;
  system "pkill", "-f", "uzbl.*$articleUrl";
}

    }
  }
}

sub cell($){
  my $cell = shift;
  $cell =~ s/\&amp;/\&/g;
  if($cell =~ /\Q$csvDelim\E/ or $cell =~ /\Q"\E/){
    $cell =~ s/"/""/g;
    $cell = "\"$cell\"";
    return $cell;
  }else{
    return $cell;
  }
}

sub csv($){
  my $eps = shift;
  my $csv = '';
  for my $epNum(sort keys %$eps){
    my $ep = $$eps{$epNum};
    my @cols = (
      cell $$ep{number},
      cell $$ep{title},
      cell $$ep{author},
      cell $$ep{reader},
      cell $$ep{date},
      cell $$ep{articleUrl},
    );
    $csv .= join($csvDelim, @cols) . "\n";
  }
  return $csv;
}

sub parseTableRow($$){
  my $tr = shift;
  my $maxLen = shift;

  $tr =~ /href="(http:\/\/escapepod.org\/(\d+\/\d+\/\d+)\/[^"]*)"/;
  my $articleUrl = $1;
  my $date = $2;

  $tr =~ s/\n/ /g;
  $tr =~ s/>\s*/>/g;
  $tr =~ s/\s*</</g;
  $tr =~ s/<a [^<>]* >  \s*(.*?)\s*  < \s* \/ \s* a \s* >/$1/gsxi;
  $tr =~ s/<td [^<>]* >  \s*(.*?)\s*  < \s* \/ \s* td \s* >/<>$1/gsxi;
  $tr =~ s/^<tr><>(.*)<>EPF<\/tr>$/$1/;
  if($tr =~ /^(\d+)<>([^<]*)<>([^<]*)<>([^<]*)<>([^<]*)<>([^<]*)$/){
    return {
      number => padl($maxLen, $1),
      title => $2,
      author => $3,
      reader => $4,
      time => $5,
      parentRating => $6,
      articleUrl => $articleUrl,
      date => $date,
    };
  }else{
    die "fucked up episode: $tr\n";
  }
}

sub padl($$){
  my ($len, $n) = @_;
  return ('0'x($len - length $n)) . $n;
}
sub maxLen(@){
  my $maxLen = 0;
  for my $s(@_){
   $maxLen = length $s if length $s > $maxLen; 
  }
  return $maxLen;
}

&main(@ARGV);
